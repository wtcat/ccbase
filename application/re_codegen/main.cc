/*
 * Copyright 2025 wtcat 
 */

#include "base/at_exit.h"
#include "base/logging.h"
#include "base/message_loop.h"
#include "base/callback.h"
#include "base/bind.h"
#include "base/timer.h"
#include "base/file_path.h"
#include "base/file_util.h"
#include "base/file_util_proxy.h"
#include "base/thread_task_runner_handle.h"
#include "base/threading/thread.h"
#include "base/threading/worker_pool.h"
#include "base/json/json_file_value_serializer.h"
#include "base/command_line.h"


namespace app {

class CodeTemplate {
public:
    CodeTemplate();

};

class CodeGenerator {
public:
    struct ResourceType {
        ResourceType(size_t namelen, size_t valuelen) {
            name.reserve(namelen);
            value.reserve(valuelen);
        }
        void Clear() {
            name.clear();
            value.clear();
        }
        std::string name;
        std::string value;
    };
    struct ViewData {
        std::string name;
        std::string value;
        std::vector<ResourceType> pictures;
        std::vector<ResourceType> strings;
    };

    CodeGenerator() { resources_.reserve(50); }
    bool ParseInput(const FilePath& path) {
        JSONFileValueSerializer json(path);
        std::string  err_message;
        base::Value* value;

        //Parse resource information file (Generated by resource convert tool)
        value = json.Deserialize(nullptr, &err_message);
        if (value == nullptr) {
            printf("Failed to parse json: %s\n", err_message.c_str());
            return false;
        }

        //Get root node
        const base::DictionaryValue* dict_value;
        const base::ListValue* list_value;
        if (!value->GetAsDictionary(&dict_value))
            return false;

        //Check file signature
        std::string str;
        str.reserve(128);

        if (!dict_value->GetString("signature", &str)) {
            printf("Not found key: \"signature\"\n");
            return false;
        }
        if (str != "ResourceInterface") {
            printf("Invalid resource interface file\n");
            return false;
        }

        //Parse resource list
        if (!dict_value->GetList("views", &list_value)) {
            printf("Not found key: \"views\"\n");
            return false;
        }

        //Walk around resource node list
        for (auto iter = list_value->begin(); 
            iter != list_value->end(); 
            ++iter) {
            std::unique_ptr<ViewData> view_ptr = std::make_unique<ViewData>();

            if (!(*iter)->GetAsDictionary(&dict_value)) {
                printf("Invalid \"views\" value\n");
                return false;
            }

            if (!dict_value->GetString("name", &view_ptr.get()->name)) {
                printf("Not found key: \"name\"\n");
                return false;
            }

            if (!dict_value->GetString("value", &view_ptr.get()->value)) {
                printf("Not found key: \"value\"\n");
                return false;
            }

            if (!ForeachListValue(dict_value, "pictures", view_ptr.get()->pictures)) {
                printf("Failed to get picture resource(view: %s)\n", view_ptr.get()->name.c_str());
                return false;
            }

            if (!ForeachListValue(dict_value, "strings", view_ptr.get()->strings)) {
                printf("Failed to get string resource(view: %s)\n", view_ptr.get()->name.c_str());
                return false;
            }

            resources_.push_back(std::move(view_ptr));
        }

        return true;
    }

    bool GenerateRsourceCode() {

        return false;
    }

    bool GenerateGuiCode() {
        return true;
    }

private:
    bool ForeachListValue(const base::DictionaryValue *value, 
        const std::string& key, 
        std::vector<ResourceType>& vector) {
        const base::ListValue* list_value;
        if (!value->GetList(key, &list_value)) {
            printf("Not found key: \"%s\"\n", key.c_str());
            return false;
        }

        //Walk around resource node list
        ResourceType resource(64, 32);
        for (auto iter = list_value->begin();
            iter != list_value->end();
            ++iter) {
            const base::DictionaryValue* dict_value;
            if (!(*iter)->GetAsDictionary(&dict_value)) {
                printf("Invalid \"views\" value\n");
                return false;
            }

            resource.Clear();
            if (!dict_value->GetString("name", &resource.name)) {
                printf("Not found key: \"name\"\n");
                return false;
            }
            if (!dict_value->GetString("value", &resource.value)) {
                printf("Not found key: \"value\"\n");
                return false;
            }
            vector.push_back(resource);
        }
        return true;
    }

private:
    std::vector<std::unique_ptr<ViewData>> resources_;
};



} //namespace app

int main(int argc, char* argv[]) {
    //CommandLine cmdline(argc, argv);
    base::AtExitManager atexit;


    return 0;
}
