/*
 * Copyright 2025 wtcat 
 */

#include <cstdlib>
#include <algorithm>

#include "base/file_path.h"
#include "base/file_util.h"
#include "base/bind.h"

#include "application/codegen/codegen.h"

namespace app {

//Class ViewIDCodeBuilder
bool ViewIDCodeBuilder::CodeWriteHeader(std::string& code) {
    code.append(
        "/*\n"
        " * Copyright 2025 wtcat (Don't edit it)\n"
        " */\n"
        "#ifndef UI_TEMPLATE_IDS_H_\n"
        "#define UI_TEMPLATE_IDS_H_\n\n"
    );
    return true;
}

bool ViewIDCodeBuilder::CodeWriteFoot(std::string& code) {
    code.append("\n#endif /* UI_TEMPLATE_IDS_H_ */\n");
    return true;
}

bool ViewIDCodeBuilder::CodeWriteBody(std::string& code) {
    ResourceParser* reptr = ResourceParser::GetInstance();
    size_t count = reptr->GetIdCount();
    for (size_t i = 0; i < count; i++) {
        char idname[8] = {0};
        itoa(i, idname, 10);
        code.append("#define ")
            .append(reptr->GetIdName(i))
            .append("  ")
            .append(itoa(i, idname, 10))
            .append("\n");
    }
    return true;
}

//Class ResourceCodeBuilder
bool ResourceCodeBuilder::CodeWriteHeader(std::string& code) {
    static const char header[] = {
        "/*\n"
        " * Copyright 2025 wtcat\n"
        " */\n"
        "\n"
        "#include \"ui_template.h\"\n"
        "\n"
        "/*\n"
        " * Helper Macro\n"
        " */\n"
        "#define SDK_RESOURCE_NUM(table) (sizeof(table) / sizeof(table[0]))\n"
        "#define SDK_RESOURCE_ITEM(view_id, scene_id, pic, txt, picset) \\\n"
        "     {picset, pic, txt, scene_id, view_id}\n"
    };
    code.clear();
    code.append(header);
    return true;
}

bool ResourceCodeBuilder::CodeWriteFoot(std::string& code) {
    static const char foot[] = {
        "UI_PUBLIC_API\n"
        "const sdk_resources_t* _sdk_view_get_resource(uint16_t view_id) {\n"
        "    if (view_id < SDK_RESOURCE_NUM(sdk_resource_table))\n"
        "        return &sdk_resource_table[view_id];\n"
        "    return NULL;\n"
        "}\n"
    };

    ResourceTableFill(code);
    code.append(foot);
    return true;
}

bool ResourceCodeBuilder::CodeWriteBody(std::string& code) {
    ResourceParser::GetInstance()->ForeachView(
        base::Bind(&ResourceCodeBuilder::ResourceCallback, this),
        code);
    return true;
}

void ResourceCodeBuilder::ResourceCallback(const ResourceParser::ViewData& view,
    std::string& code) {
    char symbol_name[256];

    auto generate_fn = [&](const std::string& name, 
        const std::vector<ResourceParser::ResourceType> &vec,
        const char* extname) ->void {
        if (vec.size() > 0) {
            char buf[128];
            snprintf(buf, sizeof(buf),
                "\n/* %s */\nSDK_RESOURCE_DEFINE(%s_%s,\n", 
                name.c_str(), 
                symbol_name,
                extname
            );
            code.append(buf);
            for (const auto& iter : vec)
                code.append("\t_RESOURCE_ITEM(").append(iter.name).append("),\n");
            code.append(");\n");
        }
    };

    size_t len = StringToLower(view.name.c_str(), symbol_name, sizeof(symbol_name) - 1);
    symbol_name[len] = '\0';

    //Picture resource
    generate_fn(view.name, view.pictures, "pic");

    //String resource
    generate_fn(view.name, view.strings, "txt");

    //Collect variable information
    scoped_ptr<ResourceNode> item(new ResourceNode());
    item->view = view_ids_++;
    item->scene = view.value;
    item->picture.append(symbol_name).append("_pic");
    item->text.append(symbol_name).append("_txt");
    nodes_.push_back(std::move(item));
}

void ResourceCodeBuilder::ResourceTableFill(std::string& code) {
    static const char header[] = {
        "\n\n"
        "/*\n"
        " * Resource table\n"
        " */\n"
        "static const sdk_resources_t sdk_resource_table[] = {\n"
    };

    //Append resource table header
    code.append(header);

    //Sort view ID
    std::sort(nodes_.begin(), nodes_.end(), Less());

    //Generate resource table item
    for (const auto& iter : nodes_) {
        code.append("\tSDK_RESOURCE_ITEM(")
            .append(ResourceParser::GetInstance()->GetIdName(iter->view)).append(", ")
            .append(iter->scene).append(", ")
            .append(iter->picture).append(", ")
            .append(iter->text).append(", ")
            .append(iter->anim.size() ? iter->anim : "NULL").append("),\n");
    }

    //Append resource table foot
    code.append("};\n\n\n");
}


//Class ResourceParser
bool ResourceParser::ParseInput(const FilePath& path) {
    JSONFileValueSerializer json(path);
    std::string  err_message;
    base::Value* value;

    if (valid())
        return true;

    //Parse resource information file (Generated by resource convert tool)
    value = json.Deserialize(nullptr, &err_message);
    if (value == nullptr) {
        printf("Failed to parse json: %s\n", err_message.c_str());
        return false;
    }

    //Get root node
    const base::DictionaryValue* dict_value;
    const base::ListValue* list_value;
    if (!value->GetAsDictionary(&dict_value))
        return false;

    //Check file signature
    std::string str;
    str.reserve(128);

    if (!dict_value->GetString("signature", &str)) {
        printf("Not found key: \"signature\"\n");
        return false;
    }
    if (str != "ResourceInterface") {
        printf("Invalid resource interface file\n");
        return false;
    }

    //Parse resource list
    if (!dict_value->GetList("views", &list_value)) {
        printf("Not found key: \"views\"\n");
        return false;
    }

    //Walk around resource node list
    ids_.reserve(80);
    resources_.reserve(50);
    for (auto iter = list_value->begin();
        iter != list_value->end();
        ++iter) {
        std::unique_ptr<ViewData> view_ptr = std::make_unique<ViewData>();

        if (!(*iter)->GetAsDictionary(&dict_value)) {
            printf("Invalid \"views\" value\n");
            return false;
        }

        //Get view name
        if (!dict_value->GetString("name", &view_ptr.get()->name)) {
            printf("Not found key: \"name\"\n");
            return false;
        }

        //Get resource id of the view
        if (!dict_value->GetString("value", &view_ptr.get()->value)) {
            printf("Not found key: \"value\"\n");
            return false;
        }

        //Get all pictures of the view
        ForeachListValue(dict_value, "pictures", view_ptr.get()->pictures);
        std::sort(view_ptr.get()->pictures.begin(), 
            view_ptr.get()->pictures.end(), ResourceLess());

        //Get all strings of the view
        ForeachListValue(dict_value, "strings", view_ptr.get()->strings);
        std::sort(view_ptr.get()->strings.begin(),
            view_ptr.get()->strings.end(), ResourceLess());

        ids_.push_back("uID__" + view_ptr.get()->name);
        resources_.push_back(std::move(view_ptr));
    }

    return true;
}

bool ResourceParser::ForeachListValue(const base::DictionaryValue* value,
    const std::string& key,
    std::vector<ResourceType>& vector) {
    const base::ListValue* list_value;
    if (!value->GetList(key, &list_value)) {
        printf("Not found key: \"%s\"\n", key.c_str());
        return false;
    }

    //Walk around resource node list
    ResourceType resource(64, 32);
    for (auto iter = list_value->begin();
        iter != list_value->end();
        ++iter) {
        const base::DictionaryValue* dict_value;
        if (!(*iter)->GetAsDictionary(&dict_value)) {
            printf("Invalid \"views\" value\n");
            return false;
        }

        resource.Clear();
        if (!dict_value->GetString("name", &resource.name)) {
            printf("Not found key: \"name\"\n");
            return false;
        }
        if (!dict_value->GetString("value", &resource.value)) {
            printf("Not found key: \"value\"\n");
            return false;
        }
        vector.push_back(resource);
    }
    return true;
}

} //namespace app
